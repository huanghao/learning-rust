Rust标准库: [std::fmt](https://doc.rust-lang.org/std/fmt/)

格式化和打印`String`s的工具

宏`format!`是一个语法扩展，由编译器实现。通过调用这个模块里的函数在运行时把各个参数变成字符串。

# Usage

`format!`很像C语言中的printf/fprintf，Python的str.format的函数。

第一个参数是格式化字符串，它必须是一个字符串字面量；不能是一个变量（为了实现有效性检查）。编译器会根据这个格式化字符串去看后面提供的参数列表是否是合法的。

## 位置参数

"{}" "the next argument" 下一个参数
"{0}" 第n个参数

## 命令参数

Rust本身不支持像Python那样的函数命名参数。但是`format!`宏是一个语法扩展，它可以使用命名参数。

把位置参数（没有名字的那些）放到命名参数的后面是不合法的。给定了没有使用的命名参数也是不合法的。

## 参数类型

每一个参数都可以最多被指定一个类型。

> {0:x} {0:o}

这个用法是错误的，因为第一个参数不能又是16进制，同时也是8进制。

但是，也有一些情况下，制定一个特定的类型是必须的。例如：`{:.*}`用来设置小数的显示精度。

> let formatted_number = format!("{:.*}", 2, 1.234567);
> 
> assert_eq!("1.23", formatted_number)

## 格式化特性(formatting traits)

当使用某种类型来格式化一个参数的时候，实际上是要求这个参数满足某种特性。这样就实现了不同的实际类型(比如i8或者isize)用相同的类似于`{:x}`的参数类型来格式化。类型和特性的对应关系如下:

* nothing => Display
* ? => Debug
* o => Otcal
* x => LowerHex
* X => UpperHex
* p => Pointer
* b => Binary
* e => LowerExp
* E => UpperExp

这意味着任何实现了fmt::Binary特性的参数可以使用{:b}来格式化。很多的原生类型已经实现了这些特性。如果没有给定类型给定，那么就会使用Display特性。

当给你自己的类型实现一个格式化特性的时候，必须实现一个以下签名的方法::

> fn fmt(&self, f: &mut fmt::Formatter) -> fmt:Result {

## fmt::Display vs fmt::Debug

这两个格式化特性有特殊的目的。

* fmt::Display 实现表明这个类型可以被展示成UTF-8字符串。不是所有的类型都会实现这个特性。
* fmt::Debug 所有公开的类型都必须实现这个类型。一般都用于内部状态的展示。这个特性的目的就是为了调试代码，大多数情况下推荐使用#[derive(Debug)]，而且也就足够了。

## 相关的宏

format!家族有很多其他的宏，目前实现的还有：

* write!        // 第一个参数是&mut io:Write表示写入的目标
* writeln!      // 和上面类似，多加一个回车
* print!        // 格式化的字符串打印到标准输出
* println!      // 多加一个回车
* format_args!  // 后面介绍

### write!

这个宏和writeln!用来把格式化的字符串输出到一个给定的流。直接写入到流中，中间不会分配多余的字符串空间。它们会调用这个模块里的`write`函数来实现。

> use std::io::Write;
> let mut w = Vec::new();
> write!(&mut w, "Hello {}!", "world");

### format_args!

这个神奇的宏用来安全的传递一个表示格式化字符串的对象。这个对象不需要堆上的内存分配，只引用栈。实际上，上面其他的宏最后都是用它来实现的。

它的结果是一个fmt::Arguments。这个结构可以传给write或者format函数来处理格式化字符串。这个宏的目的在于防止在处理字符串的中间的内存分配。

例如，一个日志库可以在它的内部传递这个结构，只到最后确定了输出的目标，再用标准的格式化函数来处理它。

# 语法

格式化的语法是从其他语言借鉴过来的，所以看上去并不是很独特。参数使用了类似Python的语法，用{}而不是像C一样的%。

# 格式化标志

每一个变量被格式化时会转换成很多格式化标志（对应于上面语法里的format_spec），这些标志来决定字符串如何格式化。语法很大程度上来源于Python，所以看上去有点熟悉。

## 填充、对齐

填充经常和*宽度*参数一起使用。对齐可以是以下几种：

* `<` 按宽度左对齐
* `^` 居中
* `>` 右对齐

注意，有些类型并不支持对齐。好的建议是先把你的输入格式化，然后用这个字符串去填充成最后的结果。

## 符号、#、0

* `+` 用来始终显示数字类型的符号。正号默认是不打印的，而负号只有在类型实现了Signed特性的时候才显示。这个标记指定（+或者-）始终需要显示。
* `-` 未使用
* `#`
    * `#?` Debug格式化
    * `#x` 前面加`0x`
    * `#X` 前面加`0x`
    * `#b` 前面加`0b`
    * `#o` 前面加`0o`
* `0` 整数前用数字零来填充

## 宽度

用于指定“最小”宽度。如果字符串的长度小于给定的宽度，填充和对齐将生效来占满给定的宽度。

非数字类型默认用空格来填充并左对齐。数字类型默认也用空格，但是右对齐。如果数字类型给定了`0`标志，空格由`0`代替。

通过使用`$`语法，参数列表中的一个usize变量可以用来指定宽度。

使用`$`语法来引用一个参数不会影响“下一个参数”的计数。所以使用位置参数或者命名参数引用变量是一个好的习惯。

## 精度

对于非数字类型，相当于指定“最大”宽度。如果生成的字符串比给定的宽度要长，它会被截断。
对于整数，这个标记忽略。
对于浮点数，指定小数点后几位数字需要输出。
有三种方式来使用精度：

* `.N` 整数N代表精度
* `.N$` 整数N或者名字N：使用参数N（必须是usize）来指定精度
* `.*` 代表了这个`{...}`关联了参数列表中的两个输入参数而不是一般的一个：第一个代表usize精度，第二个代表被打印的值。在这种情况下，如果使用的`{<arg>:<spec>.*}`这种形式，`<arg>`代表了要打印的值，那么精度参数必须出现在`<arg>`的前面。

## 转义

字面量`{`和`}`分别用`{{`和`}}`来转义。




