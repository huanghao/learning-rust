Effective Rust [Choosing your Guarantees](https://doc.rust-lang.org/stable/book/choosing-your-guarantees.html)

Rust的一个很重要的特性是，让我们自己来选择“开销”和“安全性保证”之间的权衡。

标准库里有各种包装类型，它们在开销，效率，安全之间权衡。很多都让我们在运行时开销和编译时开销之间进行选择。

# 指针类型

## `Box<T>`

指针被一个box所有。当box离开作用域的时候，析构函数会运行，内存数据会被回收。

box在运行时是0成本的。如果你想在堆上分配一些内存，然后安全地用指针来操作，box就非常合适。box的引用转移遵守普通的转移规则，并在编译的时候检查。

## `&T` and `&mut T`

分别代表只读引用和可写引用。它们服从“读写锁”的模式，也就是说同时只有一个写引用，或者多个读引用指向同一个数据。这个检查也是在编译的时候做的，运行时没有开销。大数据情况下，这两种引用是够用的，而且成本很小。

## `*const T` and `*mut T`

这两个是C一样的指针，没有生命周期和所有权跟它们相关联。它们指向内存上的某块区域，没有任何限制。唯一的保证是，除非代码标记为不安全的`unsafe`，否则，它们都不能取引用。

它们用来构建安全的，低成本的组件，例如`Vec<T>`。在安全的代码里尽量避免使用。

## `Rc<T>`

这是第一个在运行时有开销的指针。

引用计数指针，换句话说，它允许一个数据有多个所有者，在所有的所有者都离开作用域后，数据会被释放。

在内部，它维护了一个引用计数，“refcount”， 当这个Rc被拷贝的时候，计数增加，某个Rc离开作用域后计数减少。Rc的主要责任就是确保数据会被释放。

内部数据是不能修改的。如果出现了循环引用，就会有内存泄露，在这种情况下，我们就需要有垃圾回收。

### 保证

Rc保证在所有的引用没有离开作用域之前，数据不会被释放。

当一种情况下很适合用Rc：我们需要动态的分配一些数据，并在一些只读的代码中共享这个数据的，并且不知道那部分代码会是最后使用这个数据的部分。这是`&T`的一种可替代方案，当静态检查生命周期几乎不可能，或者开发者不愿意花费大量的成本来实现这种代码的时候。

这个指针不是线程安全的，Rust不会允许它被不同的线程共享。这样就省下了实现原子操作带来的成本。

另一个有关系的指针类型是`Weak<T>`，它是没有所有权的，也不会有所有权的转移。有点类似于`&T`，但是它没有生命周期的限制，可以一直持有。在数据被所有的Rc回收了以后，它再访问的时候，就会返回`None`。在有循环引用的情况下，这个类型非常有用。

### 开销






